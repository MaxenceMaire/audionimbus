use crate::context::Context;
use crate::error::{to_option_error, SteamAudioError};
use crate::geometry::Scene;
use crate::geometry::SceneType;
use crate::open_cl::OpenClDevice;
use crate::radeon_rays::RadeonRaysDevice;

/// Manages direct and indirect sound propagation simulation for multiple sources.
///
/// Your application will typically create one simulator object and use it to run simulations with different source and listener parameters between consecutive simulation runs.
/// The simulator can also be reused across scene changes.
#[derive(Debug)]
pub struct Simulator(audionimbus_sys::IPLSimulator);

impl Simulator {
    pub fn try_new(
        context: &Context,
        simulation_settings: &SimulationSettings,
    ) -> Result<Self, SteamAudioError> {
        let simulator = unsafe {
            let simulator: *mut audionimbus_sys::IPLSimulator = std::ptr::null_mut();
            let status = audionimbus_sys::iplSimulatorCreate(
                context.as_raw_ptr(),
                &mut audionimbus_sys::IPLSimulationSettings::from(simulation_settings),
                simulator,
            );

            if let Some(error) = to_option_error(status) {
                return Err(error);
            }

            *simulator
        };

        Ok(Self(simulator))
    }

    /// Specifies the scene within which all subsequent simulations should be run.
    ///
    /// Call [`Self::commit`] after calling this function for the changes to take effect.
    ///
    /// This function cannot be called while any simulation is running.
    pub fn set_scene(&self, scene: &Scene) {
        unsafe { audionimbus_sys::iplSimulatorSetScene(self.as_raw_ptr(), scene.as_raw_ptr()) }
    }

    /// Adds a probe batch for use in subsequent simulations.
    /// Sources that require baked data can then use the data contained in the specified probe batch.
    ///
    /// Call [`Self::commit`] after calling this function for the changes to take effect.
    ///
    /// This function cannot be called while any simulation is running.
    pub fn add_probe_batch(&self) {
        todo!()
    }

    /// Removes a probe batch from use in subsequent simulations.
    /// Sources that require baked data will then stop using the data contained in the specified probe batch.
    ///
    /// Call [`Self::commit`] after calling this function for the changes to take effect.
    ///
    /// This function cannot be called while any simulation is running.
    pub fn remove_probe_batch(&self) {
        todo!()
    }

    /// Commits changes to the scene or probe batches used for simulation.
    ///
    /// Call this function after calling [`Self::set_scene`], [`Self::add_probe_batch`], or [`Self::remove_probe_batch`] for the changes to take effect.
    ///
    /// This function cannot be called while any simulation is running.
    pub fn commit(&self) {
        unsafe { audionimbus_sys::iplSimulatorCommit(self.as_raw_ptr()) }
    }

    pub fn as_raw_ptr(&self) -> audionimbus_sys::IPLSimulator {
        self.0
    }
}

#[derive(Debug)]
pub struct SimulationSettings {
    /// The types of simulation that this simulator will be used for.
    pub flags: SimulationFlags,

    // TODO: fix rustdoc comment.
    /// The type of scene that will be used for simulations via \c iplSimulatorSetScene.
    /// The scene type cannot change during the lifetime of a simulator object.
    pub scene_type: SceneType,

    /// The type of reflections effect that will be used to render the results of reflections simulation.
    /// The reflections effect type cannot change during the lifetime of a simulator object.
    pub reflection_type: ReflectionEffect,

    /// The maximum number of point samples to consider when calculating occlusion using the volumetric occlusion algorithm.
    /// Different sources can use different numbers of samples, and the number of samples can change between simulation runs, but this is the maximum value.
    /// Increasing this value results in smoother occlusion transitions, at the cost of increased CPU usage.
    pub max_num_occlusion_samples: i32,

    /// The maximum number of rays to trace from the listener when simulating reflections.
    /// You can use different numbers of rays between simulation runs, but this is the maximum value.
    /// Increasing this value results in more accurate reflections, at the cost of increased CPU usage.
    pub max_num_rays: i32,

    /// The number of directions to sample when generating diffusely reflected rays.
    /// Increasing this value may increase the accuracy of diffuse reflections.
    pub num_diffuse_samples: i32,

    /// The maximum length (in seconds) of impulse responses generated by reflection simulations.
    /// You can change this value betweeen simulation runs, but this is the maximum value.
    /// Increasing this value results in longer, more accurate reverb tails, at the cost of increased CPU and memory usage.
    pub max_duration: f32,

    /// The maximum Ambisonic order of impulse responses generated by reflection simulations.
    /// You can change this value between simulation runs, but this is the maximum value.
    /// Increasing this value results in more accurate directional variations in the impulse responses, at the cost of increased CPU and memory usage.
    pub max_order: i32,

    /// The maximum number of sources for which reflection simulations will be run at any given time.
    pub max_num_sources: i32,

    /// The number of threads used for real-time reflection simulations.
    pub num_threads: i32,

    /// If using custom ray tracer callbacks, this the number of rays that will be passed to the callbacks every time rays need to be traced.
    pub ray_batch_size: i32,

    /// The number of point samples to consider when calculating probe-to-probe visibility for pathing simulations.
    /// Baked paths may end up being occluded by dynamic objects, in which case you can configure the simulator to look for alternate paths in real time.
    /// This process will involve checking visibility between probes.
    pub num_vis_samples: i32,

    /// The sampling rate (in Hz) used for audio processing.
    pub sampling_rate: i32,

    /// The size (in samples) of the audio buffers used for audio processing.
    pub frame_size: i32,

    /// The OpenCL device being used.
    /// Only necessary if [`Self::scene_type`] is [`SceneType::RadeonRays`], or [`Self::reflection_type`] is [`ReflectionEffect::TrueAudioNext`].
    pub open_cl_device: OpenClDevice,

    /// The Radeon Rays device being used. Only necessary if [`Self::scene_type`] is [`SceneType::RadeonRays`].
    pub radeon_rays_device: RadeonRaysDevice,
}

impl From<&SimulationSettings> for audionimbus_sys::IPLSimulationSettings {
    fn from(settings: &SimulationSettings) -> Self {
        todo!()
    }
}

bitflags::bitflags! {
    /// Flags indicating which types of simulation should be enabled.
    #[derive(Debug)]
    pub struct SimulationFlags: u32 {
        /// Enable direct simulation.
        /// This includes distance attenuation, air absorption, directivity, occlusion, and transmission.
        const DIRECT = 1 << 0;

        /// Enable reflections simulation.
        /// This includes both real-time and baked simulation.
        const REFLECTIONS = 1 << 1;

        /// Enable pathing simulation.
        const PATHING = 1 << 2;
    }
}

/// Type of reflection effect algorithm to use.
#[derive(Debug)]
pub enum ReflectionEffect {
    /// Multi-channel convolution reverb.
    /// Reflections reaching the listener are encoded in an Impulse Response (IR), which is a filter that records each reflection as it arrives.
    /// This algorithm renders reflections with the most detail, but may result in significant CPU usage.
    /// Using a reflection mixer with this algorithm provides a reduction in CPU usage.
    Convolution,

    /// Parametric (or artificial) reverb, using feedback delay networks.
    /// The reflected sound field is reduced to a few numbers that describe how reflected energy decays over time.
    /// This is then used to drive an approximate model of reverberation in an indoor space.
    /// This algorithm results in lower CPU usage, but cannot render individual echoes, especially in outdoor spaces.
    /// A reflection mixer cannot be used with this algorithm.
    Parametric,

    /// A hybrid of convolution and parametric reverb.
    /// The initial portion of the IR is rendered using convolution reverb, but the later part is used to estimate a parametric reverb.
    /// The point in the IR where this transition occurs can be controlled.
    /// This algorithm allows a trade-off between rendering quality and CPU usage.
    /// An reflection mixer cannot be used with this algorithm.
    Hybrid,

    /// Multi-channel convolution reverb, using AMD TrueAudio Next for GPU acceleration.
    /// This algorithm is similar to [`Self::Convolution`], but uses the GPU instead of the CPU for processing, allowing significantly more sources to be processed.
    /// A reflection mixer must be used with this algorithm, because the GPU will process convolution reverb at a single point in your audio processing pipeline.
    TrueAudioNext,
}
